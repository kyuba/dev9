import os, subprocess, glob

# PROGRAMME FILES
sourcefiles = [ 'dev9' ]

installheaders = [ ]

# DOCUMENTATION PARAMETERS

db2Xnc = [ 'html' ]

# OPTIONS

opts = Options()
opts.Add(BoolOption('debug', 'build with debug information', False))
opts.Add(BoolOption('debugMemory', 'use alternative code fragments that will work with valgrind', False))
opts.Add(BoolOption('optimise', 'default optimisations', True))
opts.Add(BoolOption('optimiseLinking', 'special linker optimisations', True))
opts.Add(BoolOption('useAssembly', 'use assembler code (usually to bypass the default C library)', True))
opts.Add(BoolOption('skipPkgConfig', 'skip the pkg-config calls', False))



opts.Add('libdir', 'libdir base name (i.e. lib, lib32, lib64, etc)', 'lib')
opts.Add('prefix', 'prefix (static libs are fine in /usr)', '/usr/')
opts.Add('destdir', 'extra installation prefix', '')

if 'CFLAGS' in os.environ:
  opts.Add('cflags', 'additional compiler flags', os.environ['CFLAGS'])
else:
  opts.Add('cflags', 'additional compiler flags', '')






if 'LDFLAGS' in os.environ:
  opts.Add('ldflags', 'additional linker flags', os.environ['LDFLAGS'])
else:
  opts.Add('ldflags', 'additional linker flags', '')

if 'CHOST' in os.environ:
  pfx = os.environ['CHOST']
else:
  pfx = ARGUMENTS.get('arch', os.uname()[4].lower()) + '-' +\
        ARGUMENTS.get('computerVendor', 'unknown') + '-' +\
        ARGUMENTS.get('ostype', os.uname()[0].lower()) + '-' +\
        ARGUMENTS.get('cctype', 'gnu')

opts.Add('targetCHOST', 'target CHOST', pfx)

env = Environment(options = opts)

opts.Add('compilerPrefix', 'compiler prefix (usually the same as targetCHOST)', env['targetCHOST'])
opts.Update(env)

env.Append (CFLAGS = env['cflags'])

env.Append (LINKFLAGS = env['ldflags'])

Help(opts.GenerateHelpText(env))

debug           = env['debug']
optimise        = env['optimise']
optimiseLinking = env['optimiseLinking']
useAssembly     = env['useAssembly']

debugMemory     = env['debugMemory']

# ACTUAL SCRIPT

x = env['targetCHOST'].split('-')

arch            = x[0]
computerVendor  = x[1]
ostype          = x[2]
cctype          = x[3]

def scanexec(file):
#  return os.spawnlp(os.P_WAIT, file, file, '--version') == 0
  f = os.popen(file + ' --version 2>&1', 'r')
  if f:
    if f.close() == None:
      print 'have ' + file
      return True

  print 'missing ' + file
  return False

if scanexec (env['compilerPrefix'] + '-gcc'):
  env['CC'] = env['compilerPrefix'] + '-gcc';
  env['LINK'] = env['compilerPrefix'] + '-gcc';

if scanexec (env['compilerPrefix'] + '-g++'):
  env['CXX'] = env['compilerPrefix'] + '-g++';

if scanexec (env['compilerPrefix'] + '-as'):
  env['AS'] = env['compilerPrefix'] + '-as';

if scanexec (env['compilerPrefix'] + '-ar'):
  env['AR'] = env['compilerPrefix'] + '-ar';

if scanexec (env['compilerPrefix'] + '-ranlib'):
  env['RANLIB'] = env['compilerPrefix'] + '-ranlib';

# install directories

libdir          = env['destdir'] + env['prefix'] + env['libdir'] + '/'
pkgconfigpath   = libdir + 'pkgconfig/'
includedir      = env['destdir'] + env['prefix'] + 'include/duat/'
# os.environ['PKG_CONFIG_PATH']
##############

def buildDocumentation(target, source, env):
  global db2Xnc

  for i in source:
    for j in target:
      for t in db2Xnc:
        os.system ('docbook2' + t + ' ' + str(i) + ' --output documentation/' + t + '-' + str(j) + ' --nochunks')

      r = open (str(j), "w")
      r.write ("updated");
      r.close

  for i in glob.glob('documentation/*/*.html'):
    os.system ('tidy -m -i -w 80 ' + i)

  return None

docsBuilder = Builder(action = buildDocumentation)
env.Append (BUILDERS = { 'Documentation' : docsBuilder })

docsource = glob.glob ('documentation/*.xml')

for i in docsource:
  env.Documentation('reference', i)

##############
def normalise(str):
  return str.replace(' ', '').replace('_', '-')


def pathPermutateVendor(prefix):
  global computerVendor
  return [ normalise(prefix + computerVendor + '/'),
           normalise(prefix) ]

def pathPermutateCC(prefix):
  global cctype
  x = pathPermutateVendor(prefix + cctype + '/')
  if cctype == 'uclibc':
    x += pathPermutateVendor(prefix + 'gnu/')
  if cctype == 'dietlibc':
    x += pathPermutateVendor(prefix + 'gnu/')
  x += pathPermutateVendor(prefix)

  return x

def pathPermutateArch(prefix):
  global arch
  return pathPermutateCC(prefix + arch + '/') +\
         pathPermutateCC(prefix)

def pathPermutateOS(prefix):
  global ostype
  return pathPermutateArch(prefix + ostype + '/') +\
         pathPermutateArch(prefix) +\
         pathPermutateArch(prefix + 'posix/') +\
         pathPermutateArch(prefix + 'generic/')

def pathPermutateValgrind(prefix):
  global debugMemory
  if debugMemory:
    return pathPermutateOS(prefix + 'valgrind/') + pathPermutateOS(prefix)
  else:
    return pathPermutateOS(prefix)

def pathPermutateDebug():
  global debug
  if debug:
    return pathPermutateValgrind('debug/') + pathPermutateValgrind('')
  else:
    return pathPermutateValgrind('')

def pathPermutate():
  return pathPermutateDebug()

if debugMemory:
  useAssembly = False
  debug = True

if debug:
  optimiseLinking = False
  optimise = False

paths = pathPermutate()

print 'max path: ' + normalise(ostype + '/' + arch + '/' + cctype + '/' + computerVendor + '/');

codepreference = [ 'c' ]

if useAssembly:
  codepreference += [ 'S', 's' ]

def fileexists(name):
  try:
    os.stat(name)
    return True
  except:
    return False


def haveasm(name):
  global paths, useAssembly

  if not useAssembly:
    return False

  for i in paths:
    if fileexists('src/' + i + name + '.S') or fileexists('src/' + i + name + '.s'):
      return True

  return False

def findsource(name):
  global codepreference, paths
  for l in paths:
    for i in codepreference:
      n = 'src/' + l + name + '.' + i
      if fileexists(n):
        return n

  return False

def findheader(name):
  global paths
  for l in paths:
    n = 'include/' + l + name + '.h'
    if fileexists(n):
      return n

  return False

def writepkgconfig():
  return False

for i in paths:
  if fileexists('include/' + i):
    env.Append (CPPPATH = [ '#include/' + i ])

env.Append(LIBPATH = '.', CFLAGS='--std=c99 -Wall -pedantic')

if debug:
  env.Append(CFLAGS='-g')

if optimise:
  env.Append(CFLAGS='-O2', LINKFLAGS='-Wl,-s')

if optimiseLinking:
  env.Append(LINKFLAGS='-Wl,-x -Wl,--gc-sections -Wl,--sort-common')
  if ostype != 'darwin':
    env.Append(LINKFLAGS='-Wl,-z,noexecstack -Wl,-z,norelro')

if not env['skipPkgConfig']:
  env.Append(LINKFLAGS = subprocess.Popen(['pkg-config', '--libs', 'libcurie'], stdout=subprocess.PIPE).communicate()[0],
             CFLAGS = subprocess.Popen(['pkg-config', '--cflags', 'libcurie'], stdout=subprocess.PIPE).communicate()[0])

env.Append (LIBS = ['duat', 'curie'])

# adjust linker/compiler flags in pkgconfig file

sf = []

for i in sourcefiles:
  sf += [ findsource(i) ]
  if haveasm(i):
    n = findsource(i + '-highlevel');
    if n:
      sf += [ n ]

x = env.StaticLibrary('duat', sf)
env.Alias ('library', x)
env.Install (libdir, x)

for i in glob.glob('tests/*.c'):
  env.Program(i)

for i in installheaders:
  x = findheader(i)
  if x:
    env.Install (includedir, x);

env.Install(pkgconfigpath, 'libduat.pc')
env.Install(pkgconfigpath, 'libduat-hosted.pc')

env.Alias('install', [ pkgconfigpath, libdir, includedir ])
